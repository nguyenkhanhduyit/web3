import { ethers } from "hardhat";
import * as fs from "fs";
import * as path from "path";

async function main() {
    console.log("=".repeat(60));
    console.log("üöÄ ENHANCED SWAP ESTIMATION WITH PRICE ORACLE");
    console.log("=".repeat(60));

    // ƒê·ªçc th√¥ng tin ƒë√£ deploy
    const tokenInfoPath = path.join(__dirname, "../info/TokenAddress.json");
    const dexInfoPath = path.join(__dirname, "../info/SimpleDEXAddress.json");
    const priceOraclePath = path.join(__dirname, "../info/PriceOracleAddress.json");
    
    if (!fs.existsSync(tokenInfoPath) || !fs.existsSync(dexInfoPath) || !fs.existsSync(priceOraclePath)) {
        console.log("‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin deployment. Vui l√≤ng ch·∫°y script deployment tr∆∞·ªõc.");
        return;
    }

    const tokenInfo = JSON.parse(fs.readFileSync(tokenInfoPath, "utf8"));
    const dexInfo = JSON.parse(fs.readFileSync(dexInfoPath, "utf8"));
    const priceOracleInfo = JSON.parse(fs.readFileSync(priceOraclePath, "utf8"));

    console.log("üìã Th√¥ng tin contracts:");
    console.log(`   SimpleDEX: ${dexInfo.address}`);
    console.log(`   PriceOracle: ${priceOracleInfo.address}`);

    // L·∫•y signer
    const [deployer] = await ethers.getSigners();
    console.log(`\nüë§ Deployer: ${deployer.address}`);

    // L·∫•y contract instances
    const simpleDEX = await ethers.getContractAt("SimpleDEX", dexInfo.address);
    const priceOracle = await ethers.getContractAt("PriceOracle", priceOracleInfo.address);

    // L·∫•y ƒë·ªãa ch·ªâ USDT ƒë·ªÉ l√†m base currency
    const usdtAddress = tokenInfo["Tether USD"].tokenAddress;

    console.log("\n" + "=".repeat(60));
    console.log("üßÆ ENHANCED SWAP ESTIMATION");
    console.log("=".repeat(60));

    const estimationResults: any = {
        timestamp: new Date().toISOString(),
        priceOracleAddress: priceOracleInfo.address,
        estimations: []
    };

    // Test 1: ∆Ø·ªõc l∆∞·ª£ng swap BTC -> ETH
    console.log("\nüîÑ Test 1: ∆Ø·ªõc l∆∞·ª£ng swap BTC -> ETH");
    try {
        const btcAddress = tokenInfo["Bitcoin"].tokenAddress;
        const ethAddress = tokenInfo["Ethereum"].tokenAddress;
        const amountIn = ethers.utils.parseUnits("1", 18); // 1 BTC

        // ∆Ø·ªõc l∆∞·ª£ng s·ªë l∆∞·ª£ng ETH s·∫Ω nh·∫≠n ƒë∆∞·ª£c
        const amountOut = await simpleDEX.getAmountOut(btcAddress, ethAddress, amountIn);
        
        // L·∫•y gi√° BTC v√† ETH so v·ªõi USDT t·ª´ PriceOracle
        const btcPriceInUSDT = await priceOracle.getPrice(btcAddress, usdtAddress);
        const ethPriceInUSDT = await priceOracle.getPrice(ethAddress, usdtAddress);
        
        // T√≠nh gi√° tr·ªã USDT c·ªßa input v√† output
        // Gi√° t·ª´ PriceOracle ƒë√£ c√≥ 18 decimals
        const inputValueInUSDT = amountIn.mul(btcPriceInUSDT).div(ethers.utils.parseUnits("1", 18));
        const outputValueInUSDT = amountOut.mul(ethPriceInUSDT).div(ethers.utils.parseUnits("1", 18));
        
        console.log(`   Input: ${ethers.utils.formatUnits(amountIn, 18)} BTC`);
        console.log(`   Input Value: $${ethers.utils.formatUnits(inputValueInUSDT, 18)} USDT`);
        console.log(`   Output: ${ethers.utils.formatUnits(amountOut, 18)} ETH`);
        console.log(`   Output Value: $${ethers.utils.formatUnits(outputValueInUSDT, 18)} USDT`);
        console.log(`   T·ª∑ l·ªá: 1 BTC = ${ethers.utils.formatUnits(amountOut, 18)} ETH`);
        console.log(`   Gi√° tr·ªã ch√™nh l·ªách: $${ethers.utils.formatUnits(inputValueInUSDT.sub(outputValueInUSDT), 18)} USDT`);
        
        estimationResults.estimations.push({
            test: "BTC -> ETH",
            input: {
                token: "BTC",
                amount: ethers.utils.formatUnits(amountIn, 18),
                valueInUSDT: ethers.utils.formatUnits(inputValueInUSDT, 18)
            },
            output: {
                token: "ETH",
                amount: ethers.utils.formatUnits(amountOut, 18),
                valueInUSDT: ethers.utils.formatUnits(outputValueInUSDT, 18)
            },
            ratio: `${ethers.utils.formatUnits(amountOut, 18)} ETH/BTC`,
            valueDifference: ethers.utils.formatUnits(inputValueInUSDT.sub(outputValueInUSDT), 18)
        });
    } catch (error) {
        console.log("   ‚ùå Kh√¥ng th·ªÉ ∆∞·ªõc l∆∞·ª£ng swap BTC -> ETH:", error.message);
    }

    // Test 2: ∆Ø·ªõc l∆∞·ª£ng swap ETH -> BTC
    console.log("\nüîÑ Test 2: ∆Ø·ªõc l∆∞·ª£ng swap ETH -> BTC");
    try {
        const btcAddress = tokenInfo["Bitcoin"].tokenAddress;
        const ethAddress = tokenInfo["Ethereum"].tokenAddress;
        const amountIn = ethers.utils.parseUnits("10", 18); // 10 ETH

        // ∆Ø·ªõc l∆∞·ª£ng s·ªë l∆∞·ª£ng BTC s·∫Ω nh·∫≠n ƒë∆∞·ª£c
        const amountOut = await simpleDEX.getAmountOut(ethAddress, btcAddress, amountIn);
        
        // L·∫•y gi√° ETH v√† BTC so v·ªõi USDT t·ª´ PriceOracle
        const ethPriceInUSDT = await priceOracle.getPrice(ethAddress, usdtAddress);
        const btcPriceInUSDT = await priceOracle.getPrice(btcAddress, usdtAddress);
        
        // T√≠nh gi√° tr·ªã USDT c·ªßa input v√† output
        const inputValueInUSDT = amountIn.mul(ethPriceInUSDT).div(ethers.utils.parseUnits("1", 18));
        const outputValueInUSDT = amountOut.mul(btcPriceInUSDT).div(ethers.utils.parseUnits("1", 18));
        
        console.log(`   Input: ${ethers.utils.formatUnits(amountIn, 18)} ETH`);
        console.log(`   Input Value: $${ethers.utils.formatUnits(inputValueInUSDT, 18)} USDT`);
        console.log(`   Output: ${ethers.utils.formatUnits(amountOut, 18)} BTC`);
        console.log(`   Output Value: $${ethers.utils.formatUnits(outputValueInUSDT, 18)} USDT`);
        console.log(`   T·ª∑ l·ªá: 10 ETH = ${ethers.utils.formatUnits(amountOut, 18)} BTC`);
        console.log(`   Gi√° tr·ªã ch√™nh l·ªách: $${ethers.utils.formatUnits(inputValueInUSDT.sub(outputValueInUSDT), 18)} USDT`);
        
        estimationResults.estimations.push({
            test: "ETH -> BTC",
            input: {
                token: "ETH",
                amount: ethers.utils.formatUnits(amountIn, 18),
                valueInUSDT: ethers.utils.formatUnits(inputValueInUSDT, 18)
            },
            output: {
                token: "BTC",
                amount: ethers.utils.formatUnits(amountOut, 18),
                valueInUSDT: ethers.utils.formatUnits(outputValueInUSDT, 18)
            },
            ratio: `${ethers.utils.formatUnits(amountOut, 18)} BTC/10 ETH`,
            valueDifference: ethers.utils.formatUnits(inputValueInUSDT.sub(outputValueInUSDT), 18)
        });
    } catch (error) {
        console.log("   ‚ùå Kh√¥ng th·ªÉ ∆∞·ªõc l∆∞·ª£ng swap ETH -> BTC:", error.message);
    }

    // Test 3: ∆Ø·ªõc l∆∞·ª£ng swap ETH -> USDT
    console.log("\nüîÑ Test 3: ∆Ø·ªõc l∆∞·ª£ng swap ETH -> USDT");
    try {
        const ethAddress = tokenInfo["Ethereum"].tokenAddress;
        const usdtToken = tokenInfo["Tether USD"];
        const amountIn = ethers.utils.parseUnits("5", 18); // 5 ETH

        // ∆Ø·ªõc l∆∞·ª£ng s·ªë l∆∞·ª£ng USDT s·∫Ω nh·∫≠n ƒë∆∞·ª£c
        const amountOut = await simpleDEX.getAmountOut(ethAddress, usdtAddress, amountIn);
        
        // L·∫•y gi√° ETH so v·ªõi USDT t·ª´ PriceOracle
        const ethPriceInUSDT = await priceOracle.getPrice(ethAddress, usdtAddress);
        
        // T√≠nh gi√° tr·ªã USDT c·ªßa input v√† output
        const inputValueInUSDT = amountIn.mul(ethPriceInUSDT).div(ethers.utils.parseUnits("1", 18));
        const outputValueInUSDT = amountOut; // USDT c√≥ 6 decimals, gi√° tr·ªã tr·ª±c ti·∫øp
        
        console.log(`   Input: ${ethers.utils.formatUnits(amountIn, 18)} ETH`);
        console.log(`   Input Value: $${ethers.utils.formatUnits(inputValueInUSDT, 18)} USDT`);
        console.log(`   Output: ${ethers.utils.formatUnits(amountOut, usdtToken.decimals)} USDT`);
        console.log(`   Output Value: $${ethers.utils.formatUnits(amountOut, usdtToken.decimals)} USDT`);
        console.log(`   T·ª∑ l·ªá: 5 ETH = ${ethers.utils.formatUnits(amountOut, usdtToken.decimals)} USDT`);
        const valueDifference = inputValueInUSDT.sub(amountOut);
        console.log(`   Gi√° tr·ªã ch√™nh l·ªách: $${ethers.utils.formatUnits(valueDifference, usdtToken.decimals)} USDT`);
        
        estimationResults.estimations.push({
            test: "ETH -> USDT",
            input: {
                token: "ETH",
                amount: ethers.utils.formatUnits(amountIn, 18),
                valueInUSDT: ethers.utils.formatUnits(inputValueInUSDT, 18)
            },
            output: {
                token: "USDT",
                amount: ethers.utils.formatUnits(amountOut, usdtToken.decimals),
                valueInUSDT: ethers.utils.formatUnits(amountOut, usdtToken.decimals)
            },
            ratio: `${ethers.utils.formatUnits(amountOut, usdtToken.decimals)} USDT/5 ETH`,
            valueDifference: ethers.utils.formatUnits(valueDifference, usdtToken.decimals)
        });
    } catch (error) {
        console.log("   ‚ùå Kh√¥ng th·ªÉ ∆∞·ªõc l∆∞·ª£ng swap ETH -> USDT:", error.message);
    }

    // Test 4: ∆Ø·ªõc l∆∞·ª£ng swap USDT -> ETH
    console.log("\nüîÑ Test 4: ∆Ø·ªõc l∆∞·ª£ng swap USDT -> ETH");
    try {
        const ethAddress = tokenInfo["Ethereum"].tokenAddress;
        const usdtToken = tokenInfo["Tether USD"];
        const amountIn = ethers.utils.parseUnits("1000", usdtToken.decimals); // 1000 USDT

        // ∆Ø·ªõc l∆∞·ª£ng s·ªë l∆∞·ª£ng ETH s·∫Ω nh·∫≠n ƒë∆∞·ª£c
        const amountOut = await simpleDEX.getAmountOut(usdtAddress, ethAddress, amountIn);
        
        // L·∫•y gi√° ETH so v·ªõi USDT t·ª´ PriceOracle
        const ethPriceInUSDT = await priceOracle.getPrice(ethAddress, usdtAddress);
        
        // T√≠nh gi√° tr·ªã USDT c·ªßa input v√† output
        const inputValueInUSDT = amountIn; // USDT c√≥ 6 decimals
        const outputValueInUSDT = amountOut.mul(ethPriceInUSDT).div(ethers.utils.parseUnits("1", 18));
        
        console.log(`   Input: ${ethers.utils.formatUnits(amountIn, usdtToken.decimals)} USDT`);
        console.log(`   Input Value: $${ethers.utils.formatUnits(amountIn, usdtToken.decimals)} USDT`);
        console.log(`   Output: ${ethers.utils.formatUnits(amountOut, 18)} ETH`);
        console.log(`   Output Value: $${ethers.utils.formatUnits(outputValueInUSDT, 18)} USDT`);
        console.log(`   T·ª∑ l·ªá: 1000 USDT = ${ethers.utils.formatUnits(amountOut, 18)} ETH`);
        const valueDifference = inputValueInUSDT.sub(outputValueInUSDT);
        console.log(`   Gi√° tr·ªã ch√™nh l·ªách: $${ethers.utils.formatUnits(valueDifference, usdtToken.decimals)} USDT`);
        
        estimationResults.estimations.push({
            test: "USDT -> ETH",
            input: {
                token: "USDT",
                amount: ethers.utils.formatUnits(amountIn, usdtToken.decimals),
                valueInUSDT: ethers.utils.formatUnits(amountIn, usdtToken.decimals)
            },
            output: {
                token: "ETH",
                amount: ethers.utils.formatUnits(amountOut, 18),
                valueInUSDT: ethers.utils.formatUnits(outputValueInUSDT, 18)
            },
            ratio: `${ethers.utils.formatUnits(amountOut, 18)} ETH/1000 USDT`,
            valueDifference: ethers.utils.formatUnits(valueDifference, usdtToken.decimals)
        });
    } catch (error) {
        console.log("   ‚ùå Kh√¥ng th·ªÉ ∆∞·ªõc l∆∞·ª£ng swap USDT -> ETH:", error.message);
    }

    // L∆∞u k·∫øt qu·∫£
    const infoDir = path.resolve(__dirname, "../info");
    if (!fs.existsSync(infoDir)) {
        fs.mkdirSync(infoDir, { recursive: true });
    }

    fs.writeFileSync(
        path.resolve(infoDir, "enhanced-swap-estimation.json"),
        JSON.stringify(estimationResults, null, 2)
    );

    console.log("\n" + "=".repeat(60));
    console.log("‚úÖ ENHANCED SWAP ESTIMATION COMPLETED");
    console.log("üìä K·∫øt qu·∫£ ƒë√£ l∆∞u v√†o: info/enhanced-swap-estimation.json");
    console.log("=".repeat(60));
}

main().catch(e => {
    console.error(e);
    process.exit(1);
}); 